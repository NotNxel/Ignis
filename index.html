<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JJK: MAXIMUM OUTPUT</title>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(300deg, #000000, #1a0b14, #0d0d1a);
      background-size: 180% 180%;
      animation: gradient-animation 18s ease infinite;
      font-family: "Courier New", sans-serif;
    }

    @keyframes gradient-animation {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    #ui {
      position: absolute;
      top: 8%;
      width: 100%;
      text-align: center;
      color: #fff;
      pointer-events: none;
      z-index: 10;
    }

    h1 {
      font-size: 3.5rem;
      margin: 0;
      letter-spacing: 15px;
      font-weight: 900;
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.2);
      background: linear-gradient(to bottom, #fff, #444);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #technique-name {
      font-size: 2.3rem;
      color: #fff;
      margin-top: 3vh;
      font-weight: 900;
      letter-spacing: 8px;
      text-transform: uppercase;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
        0 0 20px rgba(255, 255, 255, 0.5);
      animation: text-flicker 3s infinite alternate;
      transition: all 0.3s;
    }

    @keyframes text-flicker {
      0% {
        opacity: 1;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
          0 0 20px rgba(255, 255, 255, 0.5);
      }
      5% {
        opacity: 0.8;
        text-shadow: 2px 0 rgba(255, 0, 0, 0.5),
          -2px 0 rgba(0, 255, 255, 0.5);
      }
      10% {
        opacity: 1;
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
          0 0 20px rgba(255, 255, 255, 0.5);
      }
      100% {
        opacity: 1;
        text-shadow: 0 0 20px rgba(255, 255, 255, 1),
          0 0 40px rgba(255, 255, 255, 0.8);
      }
    }

    /* Video / canvas hub */
    #video-container {
      position: absolute;
      bottom: 3%;
      left: 18%;
      transform: translateX(-50%) scaleX(-1);
      width: 85vw;
      max-width: 450px;
      height: 42vh;
      border: 2px solid rgba(255, 255, 255, 0.2);
      z-index: 20;
      background-color: #000;
      border-radius: 25px;
      overflow: hidden;
      box-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.8;
    }

    #output_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #grain {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
    }

    /* Dismantle slash system */
    #slash-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 15;
      overflow: hidden;
    }

    .slash-line {
      position: absolute;
      height: 3px;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 30, 30, 0.5) 5%,
        rgba(255, 100, 100, 0.8) 20%,
        rgba(255, 200, 200, 0.95) 40%,
        #fff 50%,
        rgba(255, 200, 200, 0.95) 60%,
        rgba(255, 100, 100, 0.8) 80%,
        rgba(255, 30, 30, 0.5) 95%,
        transparent 100%
      );
      box-shadow: 0 0 12px rgba(255, 0, 0, 1),
        0 0 35px rgba(255, 0, 0, 0.7), 0 0 60px rgba(255, 0, 0, 0.3),
        0 0 4px #fff;
      animation: slash-cut 0.5s ease-out forwards;
    }

    .slash-line.thick {
      height: 5px;
      box-shadow: 0 0 18px rgba(255, 0, 0, 1),
        0 0 50px rgba(255, 0, 0, 0.7), 0 0 80px rgba(255, 0, 0, 0.3),
        0 0 6px #fff;
    }

    .slash-line.from-right {
      animation-name: slash-cut-right;
    }

    @keyframes slash-cut {
      0% {
        clip-path: inset(0 100% 0 0);
        opacity: 1;
      }
      25% {
        clip-path: inset(0 0 0 0);
        opacity: 1;
      }
      50% {
        clip-path: inset(0 0 0 0);
        opacity: 0.7;
      }
      100% {
        clip-path: inset(0 0 0 0);
        opacity: 0;
      }
    }

    @keyframes slash-cut-right {
      0% {
        clip-path: inset(0 0 0 100%);
        opacity: 1;
      }
      25% {
        clip-path: inset(0 0 0 0);
        opacity: 1;
      }
      50% {
        clip-path: inset(0 0 0 0);
        opacity: 0.7;
      }
      100% {
        clip-path: inset(0 0 0 0);
        opacity: 0;
      }
    }

    .slash-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(
        ellipse at center,
        rgba(255, 0, 0, 0.12) 0%,
        transparent 70%
      );
      animation: flash-fade 0.25s ease-out forwards;
      pointer-events: none;
      z-index: 14;
    }

    @keyframes flash-fade {
      0% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    /* Fire Embers */
    .fire-ember {
      position: fixed;
      border-radius: 50%;
      pointer-events: none;
      z-index: 17;
    }

    /* Screen Crack Lines */
    .screen-crack {
      position: fixed;
      height: 2px;
      pointer-events: none;
      z-index: 16;
      background: linear-gradient(
        90deg,
        transparent,
        rgba(40, 0, 0, 0.9) 15%,
        rgba(80, 0, 0, 0.8) 50%,
        rgba(40, 0, 0, 0.9) 85%,
        transparent
      );
      box-shadow: 0 -1px 0 rgba(255, 255, 255, 0.15),
        0 1px 0 rgba(255, 255, 255, 0.1),
        0 0 8px rgba(255, 0, 0, 0.3);
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
</head>

<body>
  <div id="grain"></div>
  <div id="slash-container"></div>

  <div id="ui">
    <h1>呪術廻戦</h1>
    <div id="technique-name">CURSED ENERGY</div>
  </div>

  <div id="video-container">
    <video class="input_video"></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    // --- Scene, renderer, bloom ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 55;

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5,
      0.4,
      0.85
    );
    composer.addPass(bloomPass);

    // --- Particles (Limitless-style base) ---
    const COUNT = 20000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    const colors = new Float32Array(COUNT * 3);
    const sizes = new Float32Array(COUNT);

    const targetPositions = new Float32Array(COUNT * 3);
    const targetColors = new Float32Array(COUNT * 3);
    const targetSizes = new Float32Array(COUNT);

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

    const particles = new THREE.Points(
      geometry,
      new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      })
    );
    scene.add(particles);

    // --- Helper: particle layouts for each technique ---
    function getRed(i) {
      // Gojo Red spiral + core
      if (i < COUNT * 0.1) {
        const r = Math.random() * 9;
        const theta = Math.random() * 6.28;
        const phi = Math.acos(2 * Math.random() - 1);
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
          r: 3,
          g: 0.1,
          b: 0.1,
          s: 2.5
        };
      } else {
        const armCount = 3;
        const t = i / COUNT;
        const angle = t * 15 + ((i % armCount) * (Math.PI * 2) / armCount);
        const radius = 2 + t * 40;
        return {
          x: radius * Math.cos(angle),
          y: radius * Math.sin(angle),
          z: (Math.random() - 0.5) * (10 * t),
          r: 0.8,
          g: 0,
          b: 0,
          s: 1.0
        };
      }
    }

    function getBlue(i) {
      // Blue = dense attractive core + ring
      if (i < COUNT * 0.15) {
        const angle = Math.random() * Math.PI * 2;
        return {
          x: 18 * Math.cos(angle),
          y: 18 * Math.sin(angle),
          z: (Math.random() - 0.5) * 4,
          r: 0.1,
          g: 0.5,
          b: 1.5,
          s: 2.2
        };
      } else {
        const radius = 22 + Math.random() * 40;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        return {
          x: radius * Math.sin(phi) * Math.cos(theta),
          y: radius * Math.sin(phi) * Math.sin(theta),
          z: radius * Math.cos(phi),
          r: 0,
          g: 0.3,
          b: 1.7,
          s: 0.8
        };
      }
    }

    function getPurple(i) {
      // Hollow Purple = merged red+blue sphere / shell
      if (Math.random() > 0.8) {
        return {
          x: (Math.random() - 0.5) * 100,
          y: (Math.random() - 0.5) * 100,
          z: (Math.random() - 0.5) * 100,
          r: 1.3,
          g: 0.4,
          b: 1.8,
          s: 1.1
        };
      }
      const r = 24;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi),
        r: 1.5,
        g: 0.5,
        b: 2,
        s: 2.7
      };
    }

    function getVoid(i) {
      if (i < COUNT * 0.15) {
        const angle = Math.random() * Math.PI * 2;
        return {
          x: 26 * Math.cos(angle),
          y: 26 * Math.sin(angle),
          z: (Math.random() - 0.5) * 1,
          r: 1,
          g: 1,
          b: 1,
          s: 2.5
        };
      } else {
        const radius = 30 + Math.random() * 90;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        return {
          x: radius * Math.sin(phi) * Math.cos(theta),
          y: radius * Math.sin(phi) * Math.sin(theta),
          z: radius * Math.cos(phi),
          r: 0.1,
          g: 0.6,
          b: 1.0,
          s: 0.7
        };
      }
    }

    function getShrine(i) {
      const total = COUNT;
      if (i < total * 0.3) {
        return {
          x: (Math.random() - 0.5) * 80,
          y: -15,
          z: (Math.random() - 0.5) * 80,
          r: 0.4,
          g: 0,
          b: 0,
          s: 0.8
        };
      } else if (i < total * 0.4) {
        const px = ( (i % 4) < 2 ? 1 : -1 ) * 12;
        const pz = ( (i % 4) % 2 === 0 ? 1 : -1 ) * 8;
        return {
          x: px + (Math.random() - 0.5) * 2,
          y: -15 + Math.random() * 30,
          z: pz + (Math.random() - 0.5) * 2,
          r: 0.2,
          g: 0.2,
          b: 0.2,
          s: 0.6
        };
      } else if (i < total * 0.6) {
        const t = Math.random() * Math.PI * 2;
        const rad = Math.random() * 30;
        const curve = Math.pow(rad / 30, 2) * 10;
        return {
          x: rad * Math.cos(t),
          y: 15 - curve + Math.random() * 2,
          z: rad * Math.sin(t) * 0.6,
          r: 0.6,
          g: 0,
          b: 0,
          s: 0.6
        };
      }
      return { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
    }

    function getDismantle(i) {
      if (i < COUNT * 0.02) {
        const r = Math.random() * 3;
        const theta = Math.random() * 6.28;
        const phi = Math.acos(2 * Math.random() - 1);
        return {
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi),
          r: 0.4,
          g: 0,
          b: 0,
          s: 0.6
        };
      }
      return { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
    }

    // --- Dismantle slashes + embers ---
    let slashInterval = null;
    let emberInterval = null;
    const slashContainer = document.getElementById("slash-container");

    function spawnSlash() {
      const count = 3 + Math.floor(Math.random() * 2);
      for (let s = 0; s < count; s++) {
        const slash = document.createElement("div");
        slash.className = "slash-line";
        if (Math.random() > 0.5) slash.classList.add("thick");
        const angle = -50 + Math.random() * 100;
        const top = Math.random() * 100;
        const width = 35 + Math.random() * 65;

        if (Math.random() > 0.5) {
          slash.classList.add("from-right");
          slash.style.right = `${Math.random() * 30}%`;
        } else {
          slash.style.left = `${Math.random() * 30}%`;
        }

        slash.style.top = `${top}%`;
        slash.style.width = `${width}%`;
        slash.style.transform = `rotate(${angle}deg)`;
        slashContainer.appendChild(slash);
        setTimeout(() => slash.remove(), 550);

        // cracks
        if (Math.random() > 0.4) {
          const crack = document.createElement("div");
          crack.className = "screen-crack";
          crack.style.top = `${top}%`;
          crack.style.width = `${width * 0.7}%`;
          crack.style.left = `${Math.random() * 30}%`;
          crack.style.transform = `rotate(${angle + (Math.random() - 0.5) * 20}deg)`;
          crack.animate(
            [
              { opacity: 0 },
              { opacity: 1, offset: 0.1 },
              { opacity: 0.8, offset: 0.6 },
              { opacity: 0 }
            ],
            { duration: 1200 + Math.random() * 800, fill: "forwards" }
          );
          document.body.appendChild(crack);
          setTimeout(() => crack.remove(), 2100);
        }
      }

      if (Math.random() > 0.3) {
        const flash = document.createElement("div");
        flash.className = "slash-flash";
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 280);
      }
    }

    function spawnEmbers() {
      const count = 3 + Math.floor(Math.random() * 4);
      for (let i = 0; i < count; i++) {
        const ember = document.createElement("div");
        ember.className = "fire-ember";
        const size = 2 + Math.random() * 5;
        ember.style.width = `${size}px`;
        ember.style.height = `${size}px`;
        const startX = Math.random() * 100;
        const startY = 50 + Math.random() * 50;
        ember.style.left = `${startX}%`;
        ember.style.top = `${startY}%`;
        const hue =
          Math.random() > 0.3
            ? 10 + Math.random() * 30
            : 40 + Math.random() * 15;
        const lightness = 50 + Math.random() * 20;
        ember.style.background = `hsl(${hue}, 100%, ${lightness}%)`;
        ember.style.boxShadow = `0 0 ${
          4 + size
        }px hsl(${hue}, 100%, 50%), 0 0 ${
          8 + size * 2
        }px rgba(255,80,0,0.5)`;
        const driftX = (Math.random() - 0.5) * 80;
        const riseY = -(100 + Math.random() * 200);
        const dur = 1000 + Math.random() * 1500;
        ember.animate(
          [
            { transform: "translate(0,0) scale(1)", opacity: 0.9 },
            {
              transform: `translate(${driftX * 0.3}px, ${
                riseY * 0.3
              }px) scale(0.9)`,
              opacity: 1,
              offset: 0.2
            },
            {
              transform: `translate(${driftX * 0.7}px, ${
                riseY * 0.7
              }px) scale(0.5)`,
              opacity: 0.6,
              offset: 0.7
            },
            {
              transform: `translate(${driftX}px, ${riseY}px) scale(0.1)`,
              opacity: 0
            }
          ],
          { duration: dur, fill: "forwards" }
        );
        document.body.appendChild(ember);
        setTimeout(() => ember.remove(), dur + 50);
      }
    }

    function startSlashes() {
      if (slashInterval) return;
      slashInterval = setInterval(spawnSlash, 45);
      emberInterval = setInterval(spawnEmbers, 150);
    }

    function stopSlashes() {
      if (slashInterval) {
        clearInterval(slashInterval);
        slashInterval = null;
      }
      if (emberInterval) {
        clearInterval(emberInterval);
        emberInterval = null;
      }
      document
        .querySelectorAll(".screen-crack, .fire-ember")
        .forEach((e) => e.remove());
    }

    // --- Hand tracking + dual-hand Red/Blue/Purple logic ---
    let currentTech = "neutral";
    let shakeIntensity = 0;
    const videoElement = document.querySelector(".input_video");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");
    let glowColor = "#00ffff";

    const hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7
    });

    function classifyHandGesture(lm) {
      const isUp = (tip, pip) => lm[tip].y < lm[pip].y;
      const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
      const tipsClose = Math.hypot(
        lm[8].x - lm[12].x,
        lm[8].y - lm[12].y
      );

      // Example mapping:
      // - Red: index up, middle down
      // - Blue: pinch (index–thumb)
      // - Dismantle: index+middle up, ring+pink down & very close
      // - Shrine: all fingers up
      // - Void: index+middle up, ring not up (looser)

      if (isUp(8, 6) && !isUp(12, 10)) {
        return "red";
      }
      if (pinch < 0.04) {
        return "blue";
      }
      if (
        isUp(8, 6) &&
        isUp(12, 10) &&
        !isUp(16, 14) &&
        !isUp(20, 18) &&
        tipsClose < 0.025
      ) {
        return "dismantle";
      }
      if (
        isUp(8, 6) &&
        isUp(12, 10) &&
        isUp(16, 14) &&
        isUp(20, 18)
      ) {
        return "shrine";
      }
      if (isUp(8, 6) && isUp(12, 10) && !isUp(16, 14)) {
        return "void";
      }
      return "neutral";
    }

    hands.onResults((results) => {
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      let leftGesture = "neutral";
      let rightGesture = "neutral";

      if (results.multiHandLandmarks && results.multiHandedness) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const lm = results.multiHandLandmarks[i];
          const handedness = results.multiHandedness[i].label; // "Left" or "Right"

          drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {
            color: glowColor,
            lineWidth: 5
          });
          drawLandmarks(canvasCtx, lm, {
            color: "#fff",
            lineWidth: 1,
            radius: 2
          });

          const g = classifyHandGesture(lm);
          if (handedness === "Left") leftGesture = g;
          else rightGesture = g;
        }
      }

      // Combine gestures into a global state:
      // - If one hand Red and the other Blue => Hollow Purple
      // - If any hand Dismantle => Dismantle
      // - Else if any Shrine/Void/Red/Blue => that effect (priority order)
      let next = "neutral";

      if (
        (leftGesture === "red" && rightGesture === "blue") ||
        (leftGesture === "blue" && rightGesture === "red")
      ) {
        next = "purple";
      } else if (leftGesture === "dismantle" || rightGesture === "dismantle") {
        next = "dismantle";
      } else if (leftGesture === "shrine" || rightGesture === "shrine") {
        next = "shrine";
      } else if (leftGesture === "void" || rightGesture === "void") {
        next = "void";
      } else if (leftGesture === "red" || rightGesture === "red") {
        next = "red";
      } else if (leftGesture === "blue" || rightGesture === "blue") {
        next = "blue";
      }

      updateState(next);
    });

    function updateState(tech) {
      if (currentTech === tech) return;
      currentTech = tech;
      stopSlashes();

      const nameEl = document.getElementById("technique-name");
      shakeIntensity = tech === "dismantle" ? 1.2 : tech !== "neutral" ? 0.4 : 0;

      if (tech === "shrine") {
        glowColor = "#ff0000";
        nameEl.innerText = "Domain Expansion: Malevolent Shrine";
        bloomPass.strength = 2.5;
        nameEl.style.textShadow = "0 0 20px #ff0000, 0 0 40px #ff0000";
        nameEl.style.color = "#ffcccc";
      } else if (tech === "purple") {
        glowColor = "#bb00ff";
        nameEl.innerText = "Hollow Technique: Purple";
        bloomPass.strength = 4.0;
        nameEl.style.textShadow = "0 0 25px #bb00ff, 0 0 55px #bb00ff";
        nameEl.style.color = "#eebbff";
      } else if (tech === "void") {
        glowColor = "#00ffff";
        nameEl.innerText = "Domain Expansion: Infinite Void";
        bloomPass.strength = 2.0;
        nameEl.style.textShadow = "0 0 20px #00ffff, 0 0 40px #00ffff";
        nameEl.style.color = "#ccffff";
      } else if (tech === "red") {
        glowColor = "#ff3333";
        nameEl.innerText = "Cursed Technique: Red";
        bloomPass.strength = 2.5;
        nameEl.style.textShadow = "0 0 20px #ff3333, 0 0 40px #ff3333";
        nameEl.style.color = "#ffcccc";
      } else if (tech === "blue") {
        glowColor = "#00aaff";
        nameEl.innerText = "Cursed Technique: Blue";
        bloomPass.strength = 2.2;
        nameEl.style.textShadow = "0 0 20px #00aaff, 0 0 40px #00aaff";
        nameEl.style.color = "#ccf2ff";
      } else if (tech === "dismantle") {
        glowColor = "#ff2222";
        nameEl.innerText = "Dismantle";
        bloomPass.strength = 3.0;
        nameEl.style.textShadow =
          "0 0 20px #ff2222, 0 0 40px #ff0000, 0 0 60px #990000";
        nameEl.style.color = "#ff8888";
        startSlashes();
      } else {
        glowColor = "#00ffff";
        nameEl.innerText = "Neutral State";
        bloomPass.strength = 1.0;
        nameEl.style.textShadow =
          "0 0 10px rgba(255, 255, 255, 0.8)";
        nameEl.style.color = "#fff";
      }

      // Re-target particle layout
      for (let i = 0; i < COUNT; i++) {
        let p;
        if (tech === "neutral") {
          if (i < COUNT * 0.05) {
            const r = 15 + Math.random() * 20;
            const t = Math.random() * 6.28;
            const ph = Math.random() * 3.14;
            p = {
              x: r * Math.sin(ph) * Math.cos(t),
              y: r * Math.sin(ph) * Math.sin(t),
              z: r * Math.cos(ph),
              r: 0.1,
              g: 0.1,
              b: 0.2,
              s: 0.4
            };
          } else {
            p = { x: 0, y: 0, z: 0, r: 0, g: 0, b: 0, s: 0 };
          }
        } else if (tech === "red") p = getRed(i);
        else if (tech === "blue") p = getBlue(i);
        else if (tech === "void") p = getVoid(i);
        else if (tech === "purple") p = getPurple(i);
        else if (tech === "shrine") p = getShrine(i);
        else if (tech === "dismantle") p = getDismantle(i);

        targetPositions[i * 3] = p.x;
        targetPositions[i * 3 + 1] = p.y;
        targetPositions[i * 3 + 2] = p.z;
        targetColors[i * 3] = p.r;
        targetColors[i * 3 + 1] = p.g;
        targetColors[i * 3 + 2] = p.b;
        targetSizes[i] = p.s;
      }
    }

    const cameraUtils = new Camera(videoElement, {
      onFrame: async () => {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        await hands.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });
    cameraUtils.start();

    // --- Animation loop ---
    function animate() {
      requestAnimationFrame(animate);

      if (shakeIntensity > 0) {
        renderer.domElement.style.transform = `translate(${
          (Math.random() - 0.5) * shakeIntensity * 40
        }px, ${(Math.random() - 0.5) * shakeIntensity * 40}px)`;
      } else {
        renderer.domElement.style.transform = "translate(0,0)";
      }

      const pos = particles.geometry.attributes.position.array;
      const col = particles.geometry.attributes.color.array;
      const siz = particles.geometry.attributes.size.array;

      for (let i = 0; i < COUNT * 3; i++) {
        pos[i] += (targetPositions[i] - pos[i]) * 0.1;
        col[i] += (targetColors[i] - col[i]) * 0.1;
      }
      for (let i = 0; i < COUNT; i++) {
        siz[i] += (targetSizes[i] - siz[i]) * 0.1;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;
      particles.geometry.attributes.size.needsUpdate = true;

      // Rotation behaviour
      if (currentTech === "red") {
        particles.rotation.z -= 0.1;
      } else if (currentTech === "blue") {
        particles.rotation.z += 0.08;
        particles.rotation.y -= 0.03;
      } else if (currentTech === "purple") {
        particles.rotation.z += 0.2;
        particles.rotation.y += 0.05;
      } else if (currentTech === "shrine") {
        particles.rotation.set(0, 0, 0);
      } else if (currentTech === "dismantle") {
        particles.rotation.set(
          (Math.random() - 0.5) * 0.015,
          (Math.random() - 0.5) * 0.015,
          0
        );
      } else {
        particles.rotation.y += 0.005;
      }

      composer.render();
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
