<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>JJK: MAXIMUM OVERDRIVE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'MS Mincho', serif; }
        #ui { position: absolute; top: 5%; width: 100%; text-align: center; color: white; z-index: 10; pointer-events: none; }
        h1 { font-size: 3.5rem; margin: 0; letter-spacing: 15px; font-weight: 900; background: linear-gradient(to bottom, #fff, #444); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #technique-name { font-size: 2.2rem; margin-top: 10px; font-weight: bold; letter-spacing: 10px; text-shadow: 0 0 20px #fff; }
        #video-container { position: absolute; bottom: 30px; left: 30px; width: 280px; height: 200px; border: 2px solid #333; border-radius: 15px; overflow: hidden; transform: scaleX(-1); opacity: 0.6; box-shadow: 0 0 30px rgba(0,0,0,1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        .slash { position: absolute; height: 4px; background: #fff; box-shadow: 0 0 25px #ff0000; pointer-events: none; animation: slash-anim 0.2s linear forwards; z-index: 5; }
        @keyframes slash-anim { 0% { transform: translate(-50%, -50%) scaleX(0) rotate(var(--r)); opacity: 1; } 100% { transform: translate(-50%, -50%) scaleX(5) rotate(var(--r)); opacity: 0; } }
    </style>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
    <div id="ui"><h1>呪術廻戦</h1><div id="technique-name">呪力共鳴</div></div>
    <div id="video-container"><video class="input_video"></video></div>

<script type="module">
    import * as THREE from 'three';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.z = 130;
    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const COUNT = 22000;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT * 3), col = new Float32Array(COUNT * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
    
    const mat = new THREE.PointsMaterial({ size: 1.3, vertexColors: true, blending: THREE.AdditiveBlending });
    const points = new THREE.Points(geo, mat);
    scene.add(points);

    let currentTech = 'neutral';
    const names = {
        'void': '無量空処', 'dismantle': '解', 'red': '術式反転「赫」',
        'purple': '虚式「茈」', 'shrine': '伏魔御廚子', 'mahoraga': '魔虚羅', 
        'hakari': '坐殺博徒', 'neutral': '呪力共鳴'
    };

    function spawnSlash() {
        const s = document.createElement('div'); s.className = 'slash';
        s.style.left = Math.random()*100+'%'; s.style.top = Math.random()*100+'%';
        s.style.width = '100vw'; s.style.setProperty('--r', Math.random()*360+'deg');
        document.body.appendChild(s);
        setTimeout(() => s.remove(), 200);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.6 });

    hands.onResults((res) => {
        let tech = 'neutral';
        const numHands = res.multiHandLandmarks.length;

        if (numHands === 2) {
            const h1 = res.multiHandLandmarks[0], h2 = res.multiHandLandmarks[1];
            const d = (h, a, b) => Math.hypot(h[a].x - h[b].x, h[a].y - h[b].y);
            // Hakari: Interlocking circles (both hands pinching)
            if (d(h1, 4, 8) < 0.05 && d(h2, 4, 8) < 0.05) tech = 'hakari';
            else tech = 'mahoraga';
        } else if (numHands === 1) {
            const h = res.multiHandLandmarks[0];
            const up = (i) => h[i].y < h[i-2].y;
            const d = (a, b) => Math.hypot(h[a].x - h[b].x, h[a].y - h[b].y);
            
            const index = up(8), mid = up(12), ring = up(16), pinky = up(20);
            if (index && mid && d(8, 12) < 0.03) tech = 'void';
            else if (d(4, 8) < 0.04) tech = 'purple';
            else if (index && mid && !ring) tech = 'dismantle';
            else if (index && !mid && !ring) tech = 'red';
            else if (index && mid && ring && pinky) tech = 'shrine';
        }

        if (tech !== currentTech) {
            currentTech = tech;
            document.getElementById('technique-name').innerText = names[tech];
            document.getElementById('technique-name').style.color = 
                tech === 'hakari' ? '#ff66cc' : (tech === 'void' ? '#fff' : '#0af');
        }
    });

    const video = document.querySelector('.input_video');
    new Camera(video, {onFrame: async () => {await hands.send({image: video})}, width: 480, height: 360}).start();

    function animate() {
        requestAnimationFrame(animate);
        const t = Date.now() * 0.002;
        const pa = points.geometry.attributes.position.array;
        const ca = points.geometry.attributes.color.array;

        for (let i = 0; i < COUNT; i++) {
            let tx, ty, tz, r=0, g=0.5, b=1;

            if (currentTech === 'hakari') {
                // Neon Pink Shutter Doors
                const phase = Math.floor(i / 1000);
                tx = (i % 100 - 50) * 2;
                ty = (Math.floor(i / 100) % 50 - 25) * 4;
                tz = Math.sin(t * 2 + phase) * 50;
                r = 1; g = 0.2; b = 0.7; // Neon Pink
                if (Math.sin(t * 10) > 0.7) { r = 1; g = 0.9; b = 0; } // Jackpot Flash
            } else if (currentTech === 'void') {
                const ang = i * 0.1 + t;
                const rad = (i < COUNT * 0.7) ? 55 : (i/COUNT * 260);
                tx = Math.cos(ang) * rad; ty = Math.sin(ang) * rad; tz = Math.sin(t + i)*120;
                r=0.9; g=0.9; b=1;
            } else if (currentTech === 'purple') {
                const rp = 40 + Math.sin(t*10)*5;
                tx = Math.sin(i)*rp*Math.cos(t*4); ty = Math.cos(i)*rp; tz = Math.sin(t*4)*rp;
                r=0.7; g=0; b=1;
            } else if (currentTech === 'red') {
                tx = Math.cos(i)*10; ty = 55 + Math.sin(i)*10; tz = Math.sin(t*15)*10;
                r=1; g=0; b=0;
            } else if (currentTech === 'dismantle') {
                tx = (Math.random()-0.5)*40; ty = (Math.random()-0.5)*40; tz = (Math.random()-0.5)*40;
                r=1; g=1; b=1;
                if (Math.random() > 0.92) spawnSlash();
            } else if (currentTech === 'mahoraga') {
                if (i < COUNT*0.85) { 
                    tx = (Math.random()-0.5)*70 * (i/COUNT); ty = (i/COUNT)*220 - 110; tz = 0;
                    r=0.8; g=0.8; b=0.8;
                } else { 
                    tx = Math.cos(i+t*6)*50; ty = 100; tz = Math.sin(i+t*6)*50;
                    r=1; g=0.8; b=0;
                }
            } else if (currentTech === 'shrine') {
                tx = (Math.random()-0.5)*180; ty = -90; tz = (Math.random()-0.5)*180;
                r=1; g=0.1; b=0;
            } else {
                tx = Math.sin(t+i)*40; ty = Math.cos(t+i)*40; tz = Math.sin(t)*20;
            }

            pa[i*3] += (tx - pa[i*3]) * 0.12;
            pa[i*3+1] += (ty - pa[i*3+1]) * 0.12;
            pa[i*3+2] += (tz - pa[i*3+2]) * 0.12;
            ca[i*3] += (r - ca[i*3]) * 0.1;
            ca[i*3+1] += (g - ca[i*3+1]) * 0.1;
            ca[i*3+2] += (b - ca[i*3+2]) * 0.1;
        }
        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
